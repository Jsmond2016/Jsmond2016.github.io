---
title: 数组的API
date: 2017-12-11 08:21:44
copyright: true
comments: true
post: true
tags: 
- javaScript
- Array
category: javaScript
---




## 常用操作

会改变原数组的方法（9个）：

- push() / pop() / shift() / unshift()
- splice() / reverse() / sort() 
- ES6: copyWith()  /  fill()

不会改变原数组的方法（8个）：

- slice() / join() / toLocalString() / toString() 
-  concat() / indexOf() / lastIndexOf()
- ES7：includes() 

遍历方法：

- forEach() /every() /some() /filter() 
- map() / reduce() /reduceRight() 
- ES6: find() / findIndex() 
- ES6: keys() / values() / entries() 

以上参考 [js 数组详细操作方法及解析合集](https://juejin.im/post/5b0903b26fb9a07a9d70c7e0#heading-28)

**增删操作**

- `slice(start,end)`: [start,end],不动原对象,返回截取后的对象,如果是负数则加上长度

```js
var fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
var citrus = fruits.slice(1,3);

console.log(citrus) // ["Orange", "Lemon"]
console.log(fruits) // ["Banana", "Orange", "Lemon", "Apple", "Mango"]
```

- `splice`:(直接操作原数组，同时返回删除的数组)

删除: splice(start,num)

```js
var fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
var citrus = fruits.splice(1,3);

console.log(citrus) // ["Orange", "Lemon", "Apple"]
console.log(fruits) // ["Banana", "Mango"]
  
```

  * 插入: splice(start,0,params) 第二个参数为 0

```js
let arr = [1,2,3,4]
arr.splice(0,0,5)

console.log(arr) //[5, 1, 2, 3, 4]
  
```

  * 替换: splice(start,num,params) 第二个参数非 0

```js
let arr = [1,2,3,4]
arr.splice(0,3,5)
console.log(arr) // [5, 4]

var fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.splice(2,1,"Lemon","Kiwi");
//结果为 Banana,Orange,Lemon,Kiwi,Mango

```

- join(separator): 把数组中的所有元素放入一个字符串。separator 为分隔符

- concat([string1[,string2...]]):返回连接的数组

- push() / pop() 操作数组**最后一个元素** 添加 / 删除

- shift() / unshift() 操作数组 **第一个元素** 删除 / 添加

**迭代方法**

- every:对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true  

**若收到一个空数组，此方法在一切情况下都会返回 `true`**。

```js
function isBelowThreshold(currentValue) {
  return currentValue < 40;
}

var array1 = [1, 30, 39, 29, 10, 13, 41];

console.log(array1.every(isBelowThreshold));
// expected output: false
// 去掉最后一个 41，则结果为 true

```

- some:数组中某项符合函数返回true，则整个返回true

```js
var array = [1, 2, 3, 4, 5];

var even = function(element) {
  return element % 2 === 0;
};

console.log(array.some(even));
//  true
```

- filter()：对数组中的每一项运行给定函数，返回该函数会**返回 true 的 项 组成的数组** [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)

```js
var fruits = ['apple', 'banana', 'grapes', 'mango', 'orange'];

function filterItems(query) {
  return fruits.filter(function(el) {
      return el.toLowerCase().indexOf(query.toLowerCase()) > -1;
  })
}

console.log(filterItems('ap')); // ['apple', 'grapes']
console.log(filterItems('an')); // ['banana', 'mango', 'orange']
```

- forEach()：对数组中的每一项运行给定函数。这个方法没有返回值 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)

**注意：** 没有办法中止或者跳出 `forEach()` 循环，除了抛出一个异常。

```js
var array1 = ['a', 'b', 'c'];

array1.forEach(function(element) {
  console.log(element);
});

// "a"
// "b"
// "c"
```

- map()：对数组中的每一项运行给定函数，返回每次函数调用的 **结果组成的数组**

```js
var array1 = [1, 4, 9, 16];

// pass a function to map
const map1 = array1.map(x => x * 2);

console.log(map1);
// expected output: Array [2, 8, 18, 32]
```

## ES6新增的数组方法

- `Array.from({})`: 把类数组对象转换成数组，iterable+Map+Set

```js
let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};

// ES5的写法
var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']

// ES6的写法
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']

Array.from('hello')
// ['h', 'e', 'l', 'l', 'o']
```

- `Array.of([])`: 将一组数据转换成数组 ，参考 [Array-off](http://es6.ruanyifeng.com/#docs/array#Array-of)

```js
Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
```

- `find`  用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。

```js
[1, 4, -5, 10].find((n) => n < 0)
// -5
[1, 5, 10, 15].find(function(value, index, arr) {
return value > 9;
}) // 10
```

- `findIndex` findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1

```js
[1, 5, 10, 15].findIndex(function(value, index, arr) {
return value > 9;
}) // 2
```

这两个方法都可以接受第二个参数，用来绑定回调函数的 this对象。另外，这两个方法都**可以发现NaN**，弥补了数组的IndexOf 方法的不足。

```js
[NaN].indexOf(NaN)
// -1
[NaN].findIndex(y => Object.is(NaN, y))
// 0
```

- `fill(str,start,end)`: 把一个数组填充指定对象和字符串，注意**如果是对象是浅拷贝**
- `entries`：遍历键值，案例见下文
- `keys` 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（ enumerable ）属性的键名。

```js
var obj = { foo: "bar", baz: 42 };
Object.keys(obj)
// ["foo", "baz"]
```

- `values `返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（ enumerable ）属性的键值。

```js
var obj = { foo: "bar", baz: 42 };
Object.values(obj)
// ["bar", 42]
```

综合 keys，values，entries 的使用

```js
let {keys, values, entries} = Object;
let obj = { a: 1, b: 2, c: 3 };

for (let key of keys(obj)) {
	console.log(key); // 'a', 'b', 'c'
}

for (let value of values(obj)) {
	console.log(value); // 1, 2, 3
}

for (let [key, value] of entries(obj)) {
	console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]
}
```

- `includes`：区别于 `indexOf`是可以找到 NaN

```js
let site = ['runoob', 'google', 'taobao'];
 
site.includes('runoob'); 
// true 
 
site.includes('baidu'); 
// false
```

- `flat()`: 按照一个可指定的**深度递归遍历数组**，并将所有元素与遍历到的子数组中的元素**合并为一个新数组返回**

```js
[1, 2, [3, 4]].flat()=>// [1, 2, 3, 4]

//扁平化数组
var arr1 = [1, 2, [3, 4]];
arr1.flat(); 
// [1, 2, 3, 4]

//扁平化空项
var arr4 = [1, 2, , 4, 5];
arr4.flat();
// [1, 2, 4, 5]
```

- `flatMap()`: 不改变原数组

推荐阅读：[【干货】js 数组详细操作方法及解析合集](https://juejin.im/post/5b0903b26fb9a07a9d70c7e0#heading-24)



参考资料：

- [是否改变原数组的常用方法归纳](https://blog.csdn.net/cristina_song/article/details/77917404)
- [是否改变原数组的常用方法归纳](https://www.cnblogs.com/var-chu/p/9377804.html)
- [es6 javascript对象Object.values() ， Object.entries()](https://blog.csdn.net/qq_30100043/article/details/53424346)
- [https://blog.csdn.net/qq_30100043/article/details/53303768](es6数组实例的find和findIndex)



## 数组遍历方法

1.`forEach()`

2.`sort()`

3.`join()&concat()&map()&filter()&reduce()`


- `forEach()` 遍历 接收一个函数作为参数，使用函数的方法进行遍历,这个函数必须 接受2个参数，分别为 `value` 和 `key` 
  具体举例：

```javascript
  var a = ['a','b','c','d']
  a.forEach(function(value,key){
  	console.log(value,key)
  })
  //a 0
  // b 1
  // c 2
  // d 3

  //forEach() 源代码为
  function forEach(array,x){
    for(let i =0;i<array.length;i++){
    		x(array[i],i)  //x表示为一个函数，内有2个参数，分别对应数组的 value 和 key
  	}
  }
 
```

- `sort()` 排序，底层原理使用的是[快排](http://bubkoo.com/2014/01/12/sort-algorithm/quick-sort/)，排序后自己会改变，因为自己给自己排序更节省内存空间
  使用介绍:

```javascript
// 默认是从小到大排序
var a =[8,2,6,4,7,3]
a.sort() //[2, 3, 4, 6, 7, 8]

```

  - 默认情况下从小到大排序，如果我要从大到小排序呢？
    答：给它一个比较的方向。声明一个函数 ，必须写2个参数！返回值有三种类型 ，正值，负值，0

```javascript
//自定义排序方向
function(x,y){return x-y}
function(x,y){return y-x}
function(x,y){return 0}

a.sort(function(x,y){return x-y})
//[2, 3, 4, 6, 7, 8]
a.sort(function(x,y){return y-x})
// [8, 7, 6, 4, 3, 2]
```


-   如何参照某个属性排序
    

答：原理相同，使用对应的值替换掉上面的 x  和 y。如下面的例子


```javascript
var students = ['小明','小红','小花']
var scores = { 小明: 59, 小红: 99, 小花: 80 }

对students按照分数高低从大到小排序？

students.sort(function(x,y){
    return scores[y] - scores[x];
})
//["小红", "小花", "小明"]

对students按照分数高低从小到大排序？

students.sort(function(x,y){
    return scores[x] - scores[y];
})
//["小明", "小花", "小红"]
```



-   `join()&concat()&map()&filter()&reduce()` 
- `join()` 合并数据，但是不会改变原来的值。

例子和代码如下 ：

```javascript
b = [1,2,3,4]
b.join()  //"1,2,3,4"
b.join('哈哈')  //"1哈哈2哈哈3哈哈4"
```

特点：当 `xxx.join()` 没有传参数，就默认是 `,`  即  `xxx.join() <==> xxx.join(',')`
    
- `concat()`  全称 ‘concatenate’  连接。
  
- 简单用法：使用  `concat()` 连接两个值
  

 例子和代码如下：

```javascript
a = [1,2,3]
b= [4,5,6]
a+b //"1,2,34,5,6"
使用简单的 "+" 导致结果不是我们想要的，那么，我们使用 concat()试试
a.concat(b)
//生成一个新数组。
//[1, 2, 3, 4, 5, 6]
```

- 巧妙用法：复制另一个值，但是二者不相等。

以数组为例，代码如下：

```javascript
a = [1,2,3]	
var b = a.concat([])  //传入参数为一个空数组
b //[1, 2, 3]
a === b //false  虽然二者数值是相等的，但是因为产生的是新数组，所以和原来的不同。
```

- `map()` 映射。功能和 `forEach()` 相同，唯一不同的是 `map()`  有返回值，返回结果为一个新数组。而 `forEach()` 没有返回值。原来的值没有改变。

使用例子如下:

```javascript
a = [1,2,3,4]
a.map(function(value,key){return value*2})  //这里的key没有别使用，可以按需求选择。
//[2, 4, 6, 8]

也可以使用箭头函数
a.map(value=>value*3)
//[3, 6, 9, 12]
```

- `filter()` 过滤。和上面的使用方式相似，接收一个函数进行操作。原来的数值不改变。

```javascript
a = [1,2,3,4,5,6,7,8,9,0]
a.filter(function(value,key){
return value>=5  //筛选值大于等于5的值
})
// [6, 7, 8, 9, 0]
a //[1,2,3,4,5,6,7,8,9,0]
```

- 和 `map()` 结合使用

```javascript
a = [1,2,3,4,5,6,7,8,9,0]
a.filter(function(key,value){
	return value>=5
}).map(function(value,key){
    return value*3
})
// [18, 21, 24, 27, 0]
```

- `reduce()` 减少，压缩

代码示例:

```javascript
//我们举一个求和的例子：
a = [1,2,3,4,5,6,7,8,9,0]
for(let i=0;i<a.length;i++){
	sum += a[i];
}
//45

// 使用 reduce() 得到同样的结果。
a.reduce(function(sum,n){	 //sum为之前的结果，n为当前的数字
	return sum + n	 		//return 的结果作为下一次遍历的结果
},0)  					   //sum 的初始值为0
//45
```

​      


参考链接：

> [sort-MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
>
> [Array.prototype.map()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map)